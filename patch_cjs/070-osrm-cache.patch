diff --git a/apps/web/src/pages/Logistics.tsx b/apps/web/src/pages/Logistics.tsx
index 89acae2..144cd92 100644
--- a/apps/web/src/pages/Logistics.tsx
+++ b/apps/web/src/pages/Logistics.tsx
@@ -9,6 +9,7 @@ import { Button } from '@/components/ui/button';
 import { Input } from '@/components/ui/input';
 import TaskTable from '../components/TaskTable';
 import { useTranslation } from 'react-i18next';
+import { useToast } from '../context/useToast';
 import mapLibrary, {
   type AttributionControl,
   type ExpressionSpecification,
@@ -109,6 +110,8 @@ const LOGISTICS_EVENT_DEBOUNCE_MS = getNodeEnv() === 'test' ? 0 : 400;
 
 export const LOGISTICS_FLEET_POLL_INTERVAL_MS = 15_000;
 
+const ROUTE_FETCH_CONCURRENCY = 4;
+
 type TaskRouteStatusKey = RoutePlanStatus | 'unassigned';
 type RouteStatusFilterKey = TaskRouteStatusKey | 'vehicle';
 
@@ -639,6 +642,48 @@ const toPosition = (coords?: Coords | null): [number, number] | null => {
 
 const hasCoords = (coords?: Coords | null) => Boolean(toPosition(coords));
 
+type Semaphore = {
+  run: <T>(task: () => Promise<T>) => Promise<T>;
+};
+
+const createSemaphore = (limit: number): Semaphore => {
+  const queue: Array<() => void> = [];
+  let active = 0;
+  const normalizedLimit = Number.isFinite(limit) && limit > 0 ? limit : 1;
+
+  const release = () => {
+    active -= 1;
+    const next = queue.shift();
+    if (next) {
+      next();
+    }
+  };
+
+  const acquire = () =>
+    new Promise<void>((resolve) => {
+      const tryAcquire = () => {
+        if (active < normalizedLimit) {
+          active += 1;
+          resolve();
+        } else {
+          queue.push(tryAcquire);
+        }
+      };
+      tryAcquire();
+    });
+
+  const run = async <T>(task: () => Promise<T>): Promise<T> => {
+    await acquire();
+    try {
+      return await task();
+    } finally {
+      release();
+    }
+  };
+
+  return { run };
+};
+
 const normalizeLocation = (value: unknown): string => {
   if (typeof value !== 'string') {
     return '';
@@ -931,6 +976,7 @@ const shouldWarnAddressConfig = MAP_ADDRESSES_PMTILES_SOURCE !== 'env';
 
 export default function LogisticsPage() {
   const { t, i18n } = useTranslation();
+  const { addToast } = useToast();
   const collapseToggleLabels = React.useMemo(
     () => ({
       collapse: t('logistics.collapseSection', {
@@ -961,6 +1007,7 @@ export default function LogisticsPage() {
   const attributionAddedRef = React.useRef(false);
   const mapContainerRef = React.useRef<HTMLDivElement | null>(null);
   const drawRef = React.useRef<MapLibreDraw | null>(null);
+  const osrmWarningShownRef = React.useRef(false);
   const persistedLayerVisibilityRef = React.useRef<LayerVisibilityState | null>(
     getPersistedLayerVisibility(),
   );
@@ -3275,19 +3322,48 @@ export default function LogisticsPage() {
       return;
     }
     let cancelled = false;
+    const semaphore = createSemaphore(ROUTE_FETCH_CONCURRENCY);
+    const routeCandidates = sorted.flatMap((task) => {
+      if (!task.startCoordinates || !task.finishCoordinates) {
+        return [];
+      }
+      const startPosition = toPosition(task.startCoordinates);
+      const finishPosition = toPosition(task.finishCoordinates);
+      if (!startPosition || !finishPosition) {
+        return [];
+      }
+      return [
+        {
+          task,
+          start: task.startCoordinates,
+          finish: task.finishCoordinates,
+        },
+      ];
+    });
     (async () => {
       const lineFeatures: GeoJSON.Feature<GeoJSON.LineString>[] = [];
       const animationRoutes: AnimatedRoute[] = [];
-      for (const task of sorted) {
+      const results = await Promise.allSettled(
+        routeCandidates.map((candidate) =>
+          semaphore.run(async () => {
+            const geometry = await fetchRouteGeometry(
+              candidate.start,
+              candidate.finish,
+            );
+            return { task: candidate.task, geometry };
+          }),
+        ),
+      );
+      if (cancelled) return;
+      let osrmFailed = false;
+      for (const result of results) {
         if (cancelled) break;
-        const start = toPosition(task.startCoordinates);
-        const finish = toPosition(task.finishCoordinates);
-        if (!start || !finish) continue;
-        const geometry = await fetchRouteGeometry(
-          task.startCoordinates,
-          task.finishCoordinates,
-        );
-        if (!geometry || cancelled) continue;
+        if (result.status !== 'fulfilled') {
+          osrmFailed = true;
+          continue;
+        }
+        const { task, geometry } = result.value;
+        if (!geometry) continue;
         const statusKey =
           typeof task.status === 'string' ? task.status.trim() : '';
         const routeColor = TASK_STATUS_COLORS[statusKey] ?? '#2563eb';
@@ -3327,6 +3403,16 @@ export default function LogisticsPage() {
       } else {
         runRouteAnimation();
       }
+      if (osrmFailed && !osrmWarningShownRef.current) {
+        addToast(
+          'Сервис маршрутизации временно недоступен, показаны доступные данные.',
+          'error',
+        );
+        osrmWarningShownRef.current = true;
+      }
+      if (!osrmFailed) {
+        osrmWarningShownRef.current = false;
+      }
     })();
     return () => {
       cancelled = true;
@@ -3335,6 +3421,7 @@ export default function LogisticsPage() {
   }, [
     layerVisibility.tasks,
     mapReady,
+    addToast,
     runRouteAnimation,
     sorted,
     stopRouteAnimation,
diff --git a/apps/web/src/services/osrm.ts b/apps/web/src/services/osrm.ts
index 11931e6..104f89a 100644
--- a/apps/web/src/services/osrm.ts
+++ b/apps/web/src/services/osrm.ts
@@ -1,26 +1,73 @@
 // Назначение: получение маршрута через OSRM
 // Основные модули: fetch
-const isValidPoint = (point?: { lng: number; lat: number }) => {
+import type { Position } from 'geojson';
+
+type Point = { lng: number; lat: number };
+
+type CacheEntry = { value: Position[] | null; expiresAt: number };
+
+const DEFAULT_ROUTE_CACHE_TTL_MS = 10 * 60 * 1000;
+
+const getRouteCacheTtl = (): number => {
+  const rawTtl = import.meta.env.VITE_ROUTE_CACHE_TTL_MS;
+  const parsed = rawTtl ? Number.parseInt(rawTtl, 10) : Number.NaN;
+  if (Number.isFinite(parsed) && parsed > 0) {
+    return parsed;
+  }
+  return DEFAULT_ROUTE_CACHE_TTL_MS;
+};
+
+const routeCache = new Map<string, CacheEntry>();
+const inflightRoutes = new Map<string, Promise<Position[] | null>>();
+
+const isValidPoint = (point?: Point) => {
   if (!point) return false;
   const { lng, lat } = point;
   return Number.isFinite(lng) && Number.isFinite(lat);
 };
 
+const buildRouteKey = (start: Point, end: Point): string =>
+  `${start.lng},${start.lat}-${end.lng},${end.lat}`;
+
 export const fetchRouteGeometry = async (
-  start: { lng: number; lat: number },
-  end: { lng: number; lat: number },
-) => {
+  start: Point,
+  end: Point,
+): Promise<Position[] | null> => {
   if (!isValidPoint(start) || !isValidPoint(end)) {
     return null;
   }
+  const now = Date.now();
+  const cacheKey = buildRouteKey(start, end);
+  const cached = routeCache.get(cacheKey);
+  if (cached && cached.expiresAt > now) {
+    return cached.value;
+  }
+  const inflight = inflightRoutes.get(cacheKey);
+  if (inflight) {
+    return inflight;
+  }
   const base =
     import.meta.env.VITE_ROUTING_URL ||
     'https://router.project-osrm.org/route/v1/driving';
   const url = `${base}/${start.lng},${start.lat};${end.lng},${end.lat}?overview=full&geometries=geojson`;
-  const res = await fetch(url);
-  if (!res.ok) return null;
-  const data = await res.json();
-  return data.routes?.[0]?.geometry?.coordinates || null;
+  const request = fetch(url)
+    .then(async (res) => {
+      if (!res.ok) {
+        throw new Error('OSRM недоступен');
+      }
+      const data = await res.json();
+      const geometry =
+        (data.routes?.[0]?.geometry?.coordinates as Position[] | undefined) ||
+        null;
+      const expiresAt = now + getRouteCacheTtl();
+      routeCache.set(cacheKey, { value: geometry, expiresAt });
+      return geometry;
+    })
+    .finally(() => {
+      inflightRoutes.delete(cacheKey);
+    });
+  inflightRoutes.set(cacheKey, request);
+  return request;
 };
 
 export default fetchRouteGeometry;
diff --git a/apps/web/src/types/env.d.ts b/apps/web/src/types/env.d.ts
index b0c10e5..b5cf7e6 100644
--- a/apps/web/src/types/env.d.ts
+++ b/apps/web/src/types/env.d.ts
@@ -8,6 +8,7 @@ declare global {
     readonly VITE_MAP_STYLE_MODE?: string;
     readonly VITE_MAP_ADDRESSES_PMTILES_URL?: string;
     readonly VITE_ROUTING_URL?: string;
+    readonly VITE_ROUTE_CACHE_TTL_MS?: string;
     readonly VITE_USE_PMTILES?: string;
     readonly VITE_LOGISTICS_POLL_INTERVAL_MS?: string;
     readonly VITE_BOT_USERNAME?: string;
