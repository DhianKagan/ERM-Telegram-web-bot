diff --git a/apps/api/src/db/queries.ts b/apps/api/src/db/queries.ts
index 0e65c19..29f16b1 100644
--- a/apps/api/src/db/queries.ts
+++ b/apps/api/src/db/queries.ts
@@ -623,16 +623,31 @@ async function enrichAttachmentsFromContent(
   const previousAttachments = Array.isArray(previous?.attachments)
     ? (previous?.attachments as Attachment[])
     : undefined;
-  if (attachmentsRaw === undefined) {
-    const commentHtml =
-      typeof data.comment === 'string' ? data.comment : undefined;
-    const derived = buildAttachmentsFromCommentHtml(commentHtml ?? '', {
-      existing: previousAttachments,
+  const commentHtml = typeof data.comment === 'string' ? data.comment : '';
+  const descriptionHtml =
+    typeof data.task_description === 'string' ? data.task_description : '';
+  let derivedAttachments: Attachment[] = Array.isArray(attachmentsRaw)
+    ? attachmentsRaw.map((item) => ({ ...item }))
+    : Array.isArray(previousAttachments)
+      ? previousAttachments.map((item) => ({ ...item }))
+      : [];
+  if (commentHtml.trim()) {
+    derivedAttachments = buildAttachmentsFromCommentHtml(commentHtml, {
+      existing: derivedAttachments,
+    });
+  }
+  if (descriptionHtml.trim()) {
+    derivedAttachments = buildAttachmentsFromCommentHtml(descriptionHtml, {
+      existing: derivedAttachments,
     });
-    if (derived.length === 0) {
+  }
+  if (attachmentsRaw === undefined) {
+    if (derivedAttachments.length === 0) {
       return undefined;
     }
-    attachmentsRaw = derived;
+    attachmentsRaw = derivedAttachments;
+  } else {
+    attachmentsRaw = derivedAttachments;
   }
   if (!Array.isArray(attachmentsRaw) || attachmentsRaw.length === 0) {
     return [];
diff --git a/apps/api/tests/taskAttachments.test.ts b/apps/api/tests/taskAttachments.test.ts
index 57ad10c..37dd754 100644
--- a/apps/api/tests/taskAttachments.test.ts
+++ b/apps/api/tests/taskAttachments.test.ts
@@ -158,6 +158,28 @@ describe('Привязка вложений к задачам', () => {
     );
   });
 
+  test('привязывает вложения из описания задачи при создании', async () => {
+    const inlineFileId = new Types.ObjectId();
+    await createTask(
+      {
+        task_description: `<p><img src="/api/v1/files/${inlineFileId}"></p>`,
+      },
+      7,
+    );
+    expect(mockFileUpdateMany).toHaveBeenNthCalledWith(
+      1,
+      {
+        _id: { $in: [inlineFileId] },
+        $or: [{ userId: 7 }, { taskId: createdTaskId }],
+      },
+      {
+        $set: { taskId: createdTaskId, detached: false, scope: 'task' },
+        $unset: { draftId: '' },
+        $addToSet: { relatedTaskIds: createdTaskId },
+      },
+    );
+  });
+
   test('разрешает первичную привязку вложений без идентификатора пользователя', async () => {
     const attachments = [
       {
@@ -228,6 +250,28 @@ describe('Привязка вложений к задачам', () => {
     });
   });
 
+  test('добавляет вложения из описания при обновлении', async () => {
+    const inlineFileId = new Types.ObjectId();
+    mockTaskFindById.mockResolvedValueOnce({
+      _id: existingTaskId,
+      status: 'Новая',
+      attachments: [],
+    });
+    await updateTask(
+      String(existingTaskId),
+      {
+        task_description: `<p><img src="/api/v1/files/${inlineFileId}"></p>`,
+      } as unknown as Record<string, unknown>,
+      1,
+    );
+
+    const call = mockTaskFindOneAndUpdate.mock.calls[0]!;
+    const setArg = call[1]?.$set as { attachments?: unknown[] };
+    expect(Array.isArray(setArg.attachments)).toBe(true);
+    const [attachment] = setArg.attachments as Record<string, unknown>[];
+    expect(attachment.url).toBe(`/api/v1/files/${inlineFileId}`);
+  });
+
   test('парсит строковое представление вложений при обновлении', async () => {
     const iso = new Date().toISOString();
     const raw = `[
