Проектирование связей между всеми сущностями в MongoDB
Описание сущностей и их взаимосвязей

В проекте задействовано несколько типов сущностей – задачи, заявки, маршрутные листы (планы маршрутов), пользователи (сотрудники) и другие объекты. Требуется, чтобы любая сущность могла быть связана с любой другой, то есть отслеживались взаимосвязи «всего со всем». Практически это означает, что каждая ключевая сущность должна хранить ссылки на связанные объекты. Например, маршрутный лист содержит список задач, привязанных к нему, а у задачи может быть ссылка на маршрутный лист, к которому она прикреплена. Пользователи (сотрудники) связываются с задачами и маршрутами в разных ролях: один пользователь может создавать много задач и маршрутных листов, а также назначаться исполнителем многих задач (классические отношения «пользователь – задачи» типа один-ко-многим). Маршрутный план, в свою очередь, включает в себя множество задач (маршрутный лист – задачи: тоже связь один-ко-многим). Заявки могут рассматриваться как особый вид задач (или иметь собственные ссылки на задачи). В сумме получаем сложный граф связей: один маршрутный план связан с несколькими задачами, каждая задача – с одним автором, возможными исполнителями и, опционально, с заявкой или маршрутом, и т.д.

Важно чётко перечислить основные парные отношения между сущностями, чтобы спроектировать хранение:

Маршрутный лист → Задачи: один маршрутный план содержит список многих задач (например, доставка нескольких заказов по маршруту). Каждая задача принадлежит максимум одному маршрутному листу. Это отношение один-ко-многим (RoutePlan → Task).

Пользователь → Задачи: один пользователь (сотрудник) может создать или выполнить много задач (один автор многих задач, один исполнитель многих задач). Задача же обычно имеет одного автора и одного основного исполнителя (это многие-к-одному с точки зрения задачи к пользователю).

Заявка → Задачи: если “заявка” моделируется отдельно, то одна заявка может порождать несколько связанных задач (например, подзадач). Это тоже отношение один-ко-многим (Request → Task). В вашем коде заявки, возможно, представлены как задачи особого типа (kind: 'request'), чтобы хранить их в общей коллекции.

Маршрутный лист → Пользователь (создатель/исполнитель): один маршрут может иметь одного создателя и одного назначенного исполнителя, но каждый пользователь со временем может создать или исполнить множество маршрутов (один-ко-многим обратное отношение).

Другие связи: Маршрутный лист связан с транспортным средством (одно ТС на маршрут, но ТС участвует в многих маршрутах), с точками остановок (набор адресов). Задача может содержать указания на гео-точки, комментарии, вложения и пр., но они обычно хранятся внутри самой задачи.

Таким образом, большая часть взаимосвязей сводится к типу «один-ко-многим» (one-to-many). Даже если на практике некоторые отношения реализуются как списки идентификаторов (например, у задачи может быть несколько соисполнителей, хранящихся в массиве – это по сути многие-ко-многим между задачами и пользователями, разбитое на два отношения один-ко-многим: задача → много пользователей и пользователь → много задач). Для упрощения проектирования мы рассматриваем каждую такую связь как две стороны один-ко-многим.

Выбор подхода хранения связей: встраивание vs. ссылки

Ключевой вопрос – где и как хранить связи? В MongoDB у нас есть два основных подхода:

Вложенные документы (embedding): хранить связанные данные как поддокументы внутри основного документа.

Ссылки (references) и запросы наподобие JOIN: хранить только идентификатор связанной сущности, а при необходимости выполнять объединение на уровне приложения или с помощью агрегирования ($lookup).

Для нашей задачи – “взаимосвязи всего со всем” – вложение всех связанных сущностей друг в друга не подходит. Этот подход работает, когда у объекта есть небольшой фиксированный набор подчинённых элементов, используемых только вместе с ним. В нашем случае задачи связаны и с маршрутами, и с пользователями, и потенциально с заявками; один и тот же объект может фигурировать в разных контекстах. Невозможно одну и ту же задачу физически вложить одновременно и в документ пользователя, и в документ маршрута, и в заявку – пришлось бы дублировать данные, что приводит к несогласованности. Поэтому оптимальным выбором является хранение ссылок (идентификаторов) на связанные документы.

Использование ссылок (Reference): В каждой сущности мы добавляем поля, содержащие ObjectId связанные сущности (или массив ObjectId, если связь один-ко-многим со стороны «один»). Например, в схеме маршрутного плана можно добавить массив tasks с идентификаторами задач, чтобы быстро получить все задачи маршрута. В схеме задачи можно хранить поле routePlanId для ссылки на связанный маршрут. Именно такой подход реализован в вашем проекте: в модели RoutePlan есть поле tasks – массив ObjectId задач, а в модели Task – поле routePlanId с ссылкой на маршрут. Также для пользователей: ID создателя и исполнителя маршрута хранятся прямо в документе RoutePlan (как числовые поля creatorId, executorId), и ID исполнителей задачи (assigned_user_id, assignees и т.п.) хранятся в документе Task. Эти идентификаторы связывают документы между собой, не дублируя всю информацию.

MongoDB не обеспечивает автоматических JOIN’ов при таких ссылках, поэтому для выборки связанных данных используются либо запросы в несколько этапов, либо агрегация с $lookup, либо возможности ODM. В Node.js ODM Mongoose упрощает задачу: можно объявить ссылочные поля с опцией ref (как выше) и потом вызывать метод .populate() для автоматической подгрузки связанных документов. Например, вызов RoutePlan.find(...).populate('tasks') под капотом выполнит второй запрос и вставит объекты задач вместо их ID. Это упрощает получение связанных данных без явного написания $lookup.

Компромисс производительности – денормализация: Несмотря на хранение только ссылок, иногда полезно дублировать часть данных связанного объекта, чтобы не делать лишний запрос. Ваш проект применяет такой паттерн для маршрутов: в документ RoutePlan помимо массива tasks (Id задач) хранится еще вложенный массив routes.tasks с объектами, содержащими основные поля задач (название, адреса, расстояние и т.д.). Эти вложенные поддокументы включают taskId задачи и несколько копий полей, чтобы сразу отобразить информацию по задачам маршрута. Таким образом, при открытии маршрутного листа не требуется загружать каждую задачу отдельно – достаточно данных из вложенных объектов. Однако полный объект задачи все равно хранится отдельно в коллекции задач, и при обновлении задачи надо помнить про обновление дублированных сведений (или принять, что в маршруте может остаться устаревшая информация). Эта техника называется денормализация и улучшает скорость чтения за счет усложнения логики записи. Применять ее следует обдуманно для часто читаемых вместе данных. В целом, базовый принцип – хранить связи через идентификаторы – остается: каждая задача знает свой routePlanId, каждый маршрут хранит список taskId задач, и т.д., а дополнительные поля могут дублироваться при необходимости.

Индексы: При хранении ссылок крайне важно индексировать поля-ссылки. Это обеспечивает быстрый поиск всех задач по routePlanId, всех маршрутов по executorId и т.д. В вашем проекте, например, установлен индекс на поле routes.tasks.taskId внутри маршрутного плана – это позволяет быстро найти маршрут, содержащий конкретную задачу, или ускоряет операции, связанные с задачами в маршрутах. Аналогично, поле routePlanId в задачах проиндексировано, чтобы быстро получать задачи по маршруту. Обязательно убедитесь, что для всех массово используемых связей есть индексы – иначе запросы начнут замедляться по мере роста данных.

Использование Mongoose для схемы и целостности

Вы указали, что в проекте задействован ODM Mongoose, что подтверждается структурой кода. Mongoose вводит схемы для MongoDB-документов, что очень полезно в нашем случае. Хотя MongoDB является schema-less (схемы не на уровне СУБД), схема фактически «переезжает» в код приложения. За счет Mongoose вы определяете строгую структуру для задач, маршрутов и прочих документов, описывая все поля и их типы. Это дисциплинирует хранение данных и предотвращает «хаос» с разнородными документами. Более того, Mongoose позволяет задать ограничения (required, enum для статусов и типов задач и т.д.), которые будут проверяться при сохранении. Уже сейчас, глядя на ваши схемы, видно использование таких ограничений – например, у задачи перечислены допустимые типы задачи и статусы, задан максимум длины для описания, и т.п..

Кроме Mongoose, рекомендуется включить валидацию схемы на уровне MongoDB (начиная с версии 3.6 MongoDB поддерживает JSON Schema Validation). Это дополнительная подстраховка: даже если кто-то минует приложение и запишет данные напрямую, MongoDB отклонит документ, не соответствующий схеме. Можно постепенно внедрять эту проверку: сначала в режиме validationLevel: moderate и action: warn (MongoDB будет писать предупреждения о несоответствии схемы, но принимать данные), затем ужесточить до строгого режима. В комбинации Mongoose + встроенная валидация вы получите надежный контракт структуры данных.

Поддержание ссылочной целостности: MongoDB не умеет автоматически поддерживать каскадные удаления или гарантировать наличие целевой ссылки (как FOREIGN KEY в SQL). Поэтому нужно самому следить за реальностью ссылок. Практика показывает, что полезно реализовать на уровне приложения:

Каскадное удаление или обновление ссылок. Например, если удаляется задача, стоит удалить её ObjectId из массива tasks в RoutePlan, или пометить задачу как удалённую, чтобы не держать «висящую» ссылку. Mongoose предоставляет хуки (pre/post remove) для таких действий, или можно писать специальные сервис-методы для удаления, которые одновременно правят связанные документы.

Ограничение удаления: наоборот, можно запрещать удалять документ, если на него есть ссылки. Например, не позволять удалить маршрутный лист, пока в нём есть задачи (требовать сначала удалить или перенести задачи). Такие бизнес-правила можно зафиксировать либо в приложении, либо с помощью [onDelete: restrict] в уровне ODM (в Mongoose нет встроенного onDelete, но можно вручную проверять).

Joint queries: если нужны сложные выборки (например, все задачи по отделу пользователя за определенный период, затрагивающие несколько коллекций), вы можете использовать агрегирование MongoDB. $lookup позволяет сделать соединение по идентификаторам прямо на сервере Mongo. В новых версиях MongoDB это работает вполне эффективно на небольших объемах данных, но на большие сложные агрегации тоже надо иметь индекс и достаточную оперативную память. Mongoose позволяет либо вручную писать агрегации (MyModel.aggregate([...])), либо иногда проще сделать несколько запросов с фильтрацией на приложении. В любом случае, наличие четких схем и индексов – основа для таких операций.

Важные выводы из доклада Томаша Борека о MongoDB

Вы приложили конспект доклада, в котором опытный специалист Tomasz Borek разбирает системные ловушки MongoDB. Рассмотрим основные моменты и как они относятся к вашему проекту:

MongoDB при обилии связей требует осторожности. Докладчик подчёркивает: если данные имеют много отношений, это серьёзный повод подумать о реляционной БД. MongoDB почти не поддерживает отношения из коробки – фактически, как мы обсуждали, все связи реализуются на уровне приложения через идентификаторы. В вашем случае данных с взаимосвязями очень много, и вы уже чувствуете эту боль (необходимость проектировать связи вручную). Это не означает, что Mongo нельзя использовать, но подразумевает, что вы должны быть особенно дисциплинированны в проектировании (что мы и делаем). Стоит заранее взвесить, не превысит ли сложность связей выгоды от использования документо-ориентированной модели. Вполне возможно, что в будущем, если требования к целостности и связям возрастут, проект может прийти к миграции на PostgreSQL или подключению дополнительной реляционной БД. Такие случаи не редкость – MongoDB часто внедряют за удобство старта, но крупные проекты потом «в слезах» переезжают на SQL, когда сталкиваются с трудностями поддержки связей и транзакционности. Осознание этого уже сейчас – полезно: вы можете либо заложить в архитектуру возможность миграции (например, придерживаться максимально нормализованной модели, чтобы было проще перенести), либо убедиться, что текущий объем и характер данных все же вписывается в возможности Mongo.

CAP и распределенность: Доклад напоминает, что обещания NoSQL о масштабируемости и отказоустойчивости имеют обратную сторону. Если ваш проект развернут как кластер (репликация, шардинг), нужно понимать связанные риски. Например, репликация: при падении primary-узла и перевыборе возможны откаты последних записей, если они не успели реплицироваться на новые primary. В старых версиях Mongo запись по умолчанию могла считаться успешной еще до фактической записи на диск (“unacknowledged writes”), что грозило потерей данных. В MongoDB 5.0+ дефолты улучшены (write concern по умолчанию majority) – теперь запись считается успешной после подтверждения большинством реплик, что безопаснее. Однако: убедитесь, что у вас в конфигурации write concern = majority и journaling включен. Это минимизирует риск потери данных при сбоях. Также тестируйте сценарии отказа (если есть репликация): как поведет себя приложение, если второй узел отстанет, и вдруг основной упадет? Нет ли случая двойной вставки или пропажи? Инструмент Jepsen-тестов упоминается как способ проверить устойчивость системы к сетевым разделениям и сбоям – в продакшен-кластере такие тесты проводить сложно, но хотя бы мысленно все «краевые случаи» надо предвидеть.

Работа с оперативной памятью (Working Set): Очень актуальный момент – все часто используемые данные и индексы должны помещаться в RAM сервера. Если рабочий набор выходит за пределы кэша, производительность MongoDB резко падает (начинаются обращения к диску, эвикции страниц из кеша WiredTiger и пр.). Ваши данные по задачам/маршрутам потенциально могут расти (каждый маршрут содержит ссылки на задачи, задачи сами по себе могут быть многочисленны). Поэтому:

Контролируйте объём наиболее важных коллекций и полей индексов. Например, индекс по routePlanId в задачах + индекс по tasks.taskId в маршрутах – они должны быть в памяти при активной работе приложения, иначе запросы по связям начнут тормозить.

Мониторинг: Используйте метрики MongoDB (например, wiredTiger.cache) – доклад советует следить за показателями page read into cache, page eviction rate. Если видите, что часто выгружаются страницы, это признак, что RAM не хватает. Решения – увеличить объем RAM или перейти на шардинг.

Оптимизация запросов: Избегайте тяжелых операций без индекса – например, не делайте сортировку по полю, по которому нет индекса, на большой коллекции задач; не используйте неоптимальные $lookup без индексов на соединяемых полях. По возможности, заменяйте устаревшие функции (MapReduce) на Aggregation Framework, как отметил спикер.

Дисциплина и явная схема: Отсутствие схемы на уровне БД – ловушка, уже обсужденная нами. Borek рекомендует явно задавать схему (JSON Schema Validation) или хотя бы тщательно поддерживать ее в коде. Мы уже внедрили Mongoose-схемы, что хорошо. Не позволяйте нескольким сервисам расходиться во мнениях о формате документов. Если появится вторая база или сервис – обеспечьте синхронизацию контрактов (общий shared модуль с типами, как у вас есть).

Маркетинг vs реальность: Доклад предупреждает, что вокруг MongoDB много маркетингового шума – легкость старта, модность, MEAN-стек. Однако реальные ограничения (CAP-теорема, отсутствие транзакций до недавнего времени, и даже сейчас многодокументные транзакции ограничены рамках одного шарда/реплики) никуда не делись. Не рассчитывайте на “сказочную” производительность или масштаб без усилий. Планируйте, тестируйте и будьте готовы, что где-то придется писать больше кода (особенно для связей, обеспечения консистентности).

Когда MongoDB – хороший выбор, а когда опасный

Докладчик привел небольшой чек-лист ситуаций:

MongoDB подходит, когда данные слабо связаны, и потери небольшого количества данных не критичны. Примеры: логирование, аналитика событий, IoT-телеметрия – там можно жертвовать частью консистентности ради скорости записи. Также Mongo удобна для маленьких проектов и прототипов, одиночных сервисов, где схема данных может быстро меняться и нет сложных запросов. В таких случаях гибкость и скорость разработки перевешивают недостатки.

MongoDB рискованна, когда требуется строгая транзакционная целостность (банковские операции, финансовые расчеты), и особенно когда много сложных связей между сущностями. В этих случаях реляционная модель часто естественнее и надежнее. Если вы планируете «зашардируем когда-нибудь потом» – это тоже тревожный звонок: шардирование нужно продумывать с самого начала, иначе при масштабировании можно получить неравномерные данные по шардам и проблемы с производительностью. Также рискованно опираться на Mongo, если у команды нет практики мониторинга и тестирования отказов – без дисциплины можно пропустить деградацию (например, не заметить, что working set уже не влезает в память, пока производительность не упадет в разы).

В вашем случае надежность связей и целостность данных важна (это не просто лог, а управленческие данные: задачи, заявки, маршруты должны соответствовать реальности). Терять данные или получать несвязанные сущности нежелательно. Значит, вы находитесь скорее в «группе риска». Тем не менее, реализовать такой проект на MongoDB можно – при условии соблюдения всех описанных мер предосторожности.

Выводы и рекомендации

Подводя итог, чтобы “отслеживать взаимосвязи всего со всем” в MongoDB без последующих сожалений, следует:

Строго определить модель данных и связи. Мы перечислили сущности и отношения между ними. Дальнейшая разработка должна придерживаться этой модели (вносить изменения только сознательно). Документируйте структуру – у вас уже есть shared-типизация и технический мануал, поддерживайте их в актуальном состоянии.

Хранить связи через идентификаторы, используя Mongoose для управления схемой. В каждой модели добавить поля ссылок на связанные объекты (как сделано для задач и маршрутов). Пример из вашего кода: маршрутный план содержит массив ссылок на задачи, а задача хранит поле со ссылкой на маршрут. Это обеспечивает гибкость – можно по ID найти связанный документ, заменить его и т.д. Mongoose .populate() и MongoDB $lookup помогут собирать связанные данные при необходимости.

Принять решение по дублированию данных (денормализации) там, где нужны быстрые отчеты. Вы уже продублировали некоторые поля задач внутри маршрута для быстрого доступа. Следите, чтобы эти дубли либо обновлялись, либо были неизменяемыми свойствами (например, адрес точки маршрута может меняться? если нет – можно смело хранить копию). Избегайте чрезмерной денормализации, чтобы не запутаться в обновлениях – только то, что действительно экономит критичный запрос.

Индексировать все основные связи. Проверить, что по каждому полю-ссылке есть индекс: task.routePlanId, routePlan.tasks.taskId (есть), routePlan.executorId/creatorId (можно добавить индекс по этим полям, если нужно часто получать маршруты определенного пользователя), task.assigned_user_id (если надо быстро искать задачи по исполнителю) и т.д. Индексы поддерживают производительность при масштабировании данных. Без индекса даже простая выборка «все задачи маршрута» превратится в полный скан коллекции задач.

Следить за объемом данных и производительностью. Вводите мониторинг: например, метрики количества задач, среднее число задач на маршрут, размеры коллекций. Как только показатели близки к пределам (RAM, диск, рост latencies запросов) – планируйте масштабирование. Если MongoDB начнет тормозить из-за объемов связных данных, рассмотрите шардирование по ключу, который равномерно распределит нагрузки (например, по какому-то атрибуту задач или маршрутов). Но помните предупреждение: шардинг «снизу доверху» требует тщательной настройки (выбор shard key, возможная денормализация под него и пр.).

Подумать о транзакционности при изменении нескольких связанных документов. Если у вас есть операции, меняющие сразу несколько коллекций (например, создание задачи должно одновременно добавить ее ID в маршрутный лист), стоит воспользоваться многодокументными транзакциями MongoDB (доступны в репликационных наборах с версии 4.0+). Транзакции в MongoDB не такие эффективные, как в SQL, но для редких административных операций подходят. Они гарантируют, что либо все связанные изменения выполнены, либо откат. Это убережет от рассинхрона – например, ситуации, когда задача создалась, а вложение ее ID в маршрут по каким-то причинам не сохранилось. С транзакцией обе операции пройдут атомарно. Альтернатива – четко прописать порядок и логику компенсации при неудаче (если второй шаг упал – откатить первый вручную).

Провести нагрузочные и интеграционные тесты сценариев работы со связями. Попробуйте на тестовом окружении создать ситуацию, когда много задач привязано к маршруту, много маршрутов у одного пользователя, и выполнить типичные запросы: вывести задачи пользователя, вывести маршрут с задачами и т.д. Посмотрите, укладываются ли задержки в допустимые. Если какие-то запросы слишком медленные, возможно, потребуется изменить схему или добавить индекс/денормализацию. Также протестируйте удаление/обновление связанных объектов: удаление пользователя – как быть с его задачами? Пока, видимо, прямой связи нет (пользователь хранится числом, а не как отдельная коллекция), но если появится – нужно решить, удалять каскадно или запрещать.

Быть готовым к изменению подхода, если требования изменятся. Сейчас вы спроектировали систему на MongoDB, но не бойтесь признавать, если где-то NoSQL не справляется. Современные проекты нередко используют гибридные решения: например, графовая БД для хранения сложных взаимосвязей (Neo4j, ArangoDB) или реляционная БД для особо критичных частей (финансовые транзакции), параллельно с MongoDB для документов. В вашем случае графовая база данных могла бы естественно моделировать «всё связано со всем» и отвечать на произвольные запросы о связях, но это добавляет новую технологию и сложность. Реляционная база (PostgreSQL) могла бы хранить те же задачи и маршруты в таблицах с внешними ключами – выиграв в целостности и удобстве JOIN-запросов, но потеряв в гибкости схемы (меньше свободы добавлять поля на лету, сложнее вложенные структуры). Решение о миграции принимается на основе роста проекта: если через некоторое время обнаружите, что постоянно обходите ограничения Mongo, пишете сложный код для эмуляции JOIN, тратите ресурсы на поддержание целостности – возможно, настал момент рассмотреть переход. Признаки этого: очень сложные агрегирующие запросы, необходимость часто обновлять множество документов сразу (что противоречит идеологии Mongo), или проблемы с производительностью из-за связей.

В заключение, MongoDB может успешно работать для вашего проекта, если соблюдать архитектурную дисциплину: хранить связи через корректные ссылки, валидировать структуру, индексировать и мониторить, предусмотреть отказоустойчивость. Вы уже предприняли многие правильные шаги. Доклад Borek’а служит напоминанием о подводных камнях – учитывайте их при дальнейшем развитии. Так вы избежите основных ловушек и сможете масштабировать систему без резких «слезливых» миграций. Все сущности будут связаны должным образом, а вы – контролировать эти связи осознанно и эффективно.

## Проверка внедрения рекомендаций (10 Feb 2026, Europe/Kyiv)

Проведена валидация по коду и тестам:

- ✅ Связь `RoutePlan -> Task` реализована в обе стороны: `RoutePlan.tasks` и `Task.routePlanId`, плюс индексы для выборок.
- ✅ Связи `User -> Task/RoutePlan` реализованы через поля `created_by`, `assigned_user_id`, `assignees`, `creatorId`, `executorId`.
- ✅ Заявки как отдельный тип задач реализованы через `Task.kind = 'request'`.
- ✅ Денормализация внутри маршрута (`routes.tasks`, `routes.stops`) присутствует.
- ✅ Референциальная целостность при удалении реализована хуками:
  - при удалении маршрута у задач сбрасывается `routePlanId`;
  - при удалении задачи её `_id` удаляется из `RoutePlan.tasks`.
- ✅ Транзакционное создание маршрутного плана реализовано через `session.withTransaction(...)` в `createDraftFromInputs`.
- ✅ Интеграционный тест `mongo_integrity.test.ts` покрывает ключевые сценарии целостности и транзакционности.
- ⚠️ Нагрузочные тесты из рекомендаций документа как отдельный автоматизированный сценарий в репозитории не выделены (есть интеграционные и функциональные тесты, но без отдельного perf-бенчмарка по связям).

### Вывод

Не всё из отчёта `mongoDB.md` внедрено буквально на 100% (главный пробел — отдельный нагрузочный контур),
но **критичные рекомендации по моделированию связей, индексации, целостности и транзакциям реализованы и проходят проверки**.
