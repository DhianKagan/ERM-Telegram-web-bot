diff --git a/apps/api/src/config.ts b/apps/api/src/config.ts
index aa65fe4..98b41db 100644
--- a/apps/api/src/config.ts
+++ b/apps/api/src/config.ts
@@ -16,7 +16,7 @@ if (!process.env.NODE_ENV && isMochaRun) {
 }
 
 const nodeEnv = process.env.NODE_ENV || 'development';
-const isTestEnvironment =
+export const isTestEnvironment =
   nodeEnv === 'test' ||
   Boolean(process.env.VITEST_WORKER_ID) ||
   Boolean(process.env.JEST_WORKER_ID) ||
@@ -298,6 +298,42 @@ const parseBooleanFlag = (
   return ['1', 'true', 'yes', 'on'].includes(normalized);
 };
 
+const geocoderEnabledFlag = parseBooleanFlag(process.env.GEOCODER_ENABLED, true);
+const geocoderBaseUrlRaw = (
+  process.env.GEOCODER_URL || 'https://nominatim.openstreetmap.org/search'
+).trim();
+let geocoderBaseUrl = geocoderBaseUrlRaw;
+if (geocoderBaseUrlRaw) {
+  try {
+    const parsed = new URL(geocoderBaseUrlRaw);
+    if (parsed.protocol !== 'http:' && parsed.protocol !== 'https:') {
+      throw new Error('GEOCODER_URL должен начинаться с http:// или https://');
+    }
+    geocoderBaseUrl = parsed.toString();
+  } catch (error) {
+    const message = error instanceof Error ? error.message : String(error);
+    if (strictEnvs.has(nodeEnv)) {
+      throw new Error(`GEOCODER_URL имеет неверный формат: ${message}`);
+    }
+    console.warn('Геокодер отключён из-за некорректного GEOCODER_URL:', message);
+    geocoderBaseUrl = '';
+  }
+}
+
+const geocoderUserAgentRaw = (process.env.GEOCODER_USER_AGENT || '').trim();
+const geocoderUserAgent = geocoderUserAgentRaw || 'ERM Logistics geocoder';
+const geocoderEmailRaw = (process.env.GEOCODER_EMAIL || '').trim();
+const geocoderEmail = geocoderEmailRaw || undefined;
+const geocoderEnabled =
+  geocoderEnabledFlag && Boolean(geocoderBaseUrl) && !isTestEnvironment;
+
+export const geocoderConfig = {
+  enabled: geocoderEnabled,
+  baseUrl: geocoderBaseUrl,
+  userAgent: geocoderUserAgent,
+  email: geocoderEmail,
+};
+
 let cookieDomainEnv = (process.env.COOKIE_DOMAIN || '').trim();
 if (cookieDomainEnv) {
   if (/^https?:\/\//.test(cookieDomainEnv)) {
@@ -434,6 +470,7 @@ const config = {
   vrpOrToolsEnabled,
   graphhopperConfig,
   graphhopper: graphhopperConfig,
+  geocoder: geocoderConfig,
 };
 
 export default config;
diff --git a/apps/api/src/geo/geocoder.ts b/apps/api/src/geo/geocoder.ts
new file mode 100644
index 0000000..6eaff26
--- /dev/null
+++ b/apps/api/src/geo/geocoder.ts
@@ -0,0 +1,90 @@
+// Назначение: прямое геокодирование адресов в координаты для логистики
+// Основные модули: config, fetch
+import { geocoderConfig } from '../config';
+import type { Coordinates } from '../db/model';
+
+const REQUEST_TIMEOUT_MS = 8000;
+
+const normalizeAddress = (value: string): string => {
+  const trimmed = value.trim();
+  return trimmed.replace(/\s+/g, ' ');
+};
+
+const parseCoordinate = (value: unknown): number | null => {
+  const num = Number(value);
+  return Number.isFinite(num) ? num : null;
+};
+
+export const geocodeAddress = async (
+  address: string,
+): Promise<Coordinates | null> => {
+  if (!geocoderConfig.enabled || !geocoderConfig.baseUrl) {
+    return null;
+  }
+
+  const normalized = normalizeAddress(address);
+  if (!normalized) {
+    return null;
+  }
+
+  const url = new URL(geocoderConfig.baseUrl);
+  if (!url.searchParams.has('format')) {
+    url.searchParams.set('format', 'json');
+  }
+  if (!url.searchParams.has('limit')) {
+    url.searchParams.set('limit', '1');
+  }
+  url.searchParams.set('q', normalized);
+  if (geocoderConfig.email) {
+    url.searchParams.set('email', geocoderConfig.email);
+  }
+
+  const headers: Record<string, string> = {
+    'User-Agent': geocoderConfig.userAgent,
+  };
+  if (geocoderConfig.email) {
+    headers['X-Nominatim-Email'] = geocoderConfig.email;
+  }
+
+  const controller = new AbortController();
+  const timeout = setTimeout(() => controller.abort(), REQUEST_TIMEOUT_MS);
+
+  try {
+    const response = await fetch(url, { headers, signal: controller.signal });
+    if (!response.ok) {
+      return null;
+    }
+    const payload = await response.json();
+    const firstItem = Array.isArray(payload) ? payload[0] : payload;
+    if (!firstItem) {
+      return null;
+    }
+    const lat = parseCoordinate(firstItem.lat ?? firstItem.latitude);
+    const lng = parseCoordinate(firstItem.lon ?? firstItem.lng ?? firstItem.longitude);
+    if (lat === null || lng === null) {
+      return null;
+    }
+    return { lat, lng } satisfies Coordinates;
+  } catch (error) {
+    const isAbort = error instanceof Error && error.name === 'AbortError';
+    const level = isAbort ? 'warn' : 'error';
+    console[level](
+      'Геокодер не вернул координаты',
+      error instanceof Error ? error.message : error,
+    );
+    return null;
+  } finally {
+    clearTimeout(timeout);
+  }
+};
+
+export const geocodeAddresses = async (addresses: string[]): Promise<Coordinates[]> => {
+  const results: Coordinates[] = [];
+  for (const item of addresses) {
+    const coords = await geocodeAddress(item);
+    if (coords) {
+      results.push(coords);
+    }
+  }
+  return results;
+};
diff --git a/apps/api/src/tasks/tasks.service.ts b/apps/api/src/tasks/tasks.service.ts
index f956d56..1004625 100644
--- a/apps/api/src/tasks/tasks.service.ts
+++ b/apps/api/src/tasks/tasks.service.ts
@@ -6,6 +6,7 @@ import { notifyTasksChanged } from '../services/logisticsEvents';
 import { generateRouteLink } from 'shared';
 import { applyIntakeRules } from '../intake/rules';
 import type { TaskDocument } from '../db/model';
+import { geocodeAddress } from '../geo/geocoder';
 import type {
   TaskFilters,
   SummaryFilters,
@@ -15,6 +16,7 @@ import { writeLog as writeAttachmentLog } from '../services/wgLogEngine';
 import { extractAttachmentIds } from '../utils/attachments';
 import { resolveTaskTypeTopicId } from '../services/taskTypeSettings';
 import { ensureTaskLinksShort } from '../services/taskLinks';
+import type { Logistics } from '../db/model';
 
 interface TasksRepository {
   createTask(
@@ -80,6 +82,12 @@ const toNumeric = (value: unknown): number | undefined => {
 const roundValue = (value: number, digits = 3) =>
   Number(Number.isFinite(value) ? value.toFixed(digits) : Number.NaN);
 
+const hasPoint = (coords?: { lat?: number | null; lng?: number | null } | null) =>
+  typeof coords?.lat === 'number' &&
+  Number.isFinite(coords.lat) &&
+  typeof coords?.lng === 'number' &&
+  Number.isFinite(coords.lng);
+
 const setMetric = (
   target: Record<string, unknown>,
   key: keyof TaskDocument,
@@ -181,6 +189,7 @@ class TasksService {
     if (payload.due_date && !payload.remind_at)
       payload.remind_at = payload.due_date;
     this.applyCargoMetrics(payload);
+    await this.applyGeocoding(payload);
     await this.applyRouteInfo(payload);
     await ensureTaskLinksShort(payload);
     await this.applyTaskTypeTopic(payload);
@@ -243,6 +252,7 @@ class TasksService {
         undefined;
     }
     this.applyCargoMetrics(payload);
+    await this.applyGeocoding(payload);
     await this.applyRouteInfo(payload);
     await ensureTaskLinksShort(payload);
     await this.applyTaskTypeTopic(payload);
@@ -314,6 +324,46 @@ class TasksService {
     }
   }
 
+  private async applyGeocoding(data: Partial<TaskDocument> = {}) {
+    const normalize = (value: unknown): string => {
+      if (typeof value !== 'string') {
+        return '';
+      }
+      const trimmed = value.trim();
+      return trimmed;
+    };
+
+    const details = (data.logistics_details ?? {}) as Logistics;
+    const startLocation = normalize(details.start_location ?? data.start_location);
+    const endLocation = normalize(details.end_location ?? data.end_location);
+
+    const shouldGeocodeStart = Boolean(startLocation) && !hasPoint(data.startCoordinates);
+    const shouldGeocodeFinish = Boolean(endLocation) && !hasPoint(data.finishCoordinates);
+
+    if (!shouldGeocodeStart && !shouldGeocodeFinish) {
+      return;
+    }
+
+    const startPromise = shouldGeocodeStart
+      ? geocodeAddress(startLocation)
+      : Promise.resolve<null>(null);
+    const finishPromise = shouldGeocodeFinish
+      ? geocodeAddress(endLocation)
+      : Promise.resolve<null>(null);
+
+    const [startCoords, finishCoords] = await Promise.all([
+      startPromise,
+      finishPromise,
+    ]);
+
+    if (startCoords) {
+      data.startCoordinates = startCoords;
+    }
+    if (finishCoords) {
+      data.finishCoordinates = finishCoords;
+    }
+  }
+
   async applyRouteInfo(data: Partial<TaskDocument> = {}) {
     const target = data as Record<string, unknown>;
     const hasStartUpdate = Object.prototype.hasOwnProperty.call(
diff --git a/apps/web/src/locales/en/translation.json b/apps/web/src/locales/en/translation.json
index 20e7cf6..c14c55d 100644
--- a/apps/web/src/locales/en/translation.json
+++ b/apps/web/src/locales/en/translation.json
@@ -205,6 +205,9 @@
     "planRouteTitle": "Route {{index}}",
     "planRouteSummary": "Tasks: {{tasks}}, stops: {{stops}}",
     "planRouteDistance": "Distance: {{distance}}",
+    "noGeoPointTitle": "Tasks without geotag",
+    "noGeoPointHint": "Address saved, waiting for geocoding.",
+    "noGeoPointLabel": "no geotag",
     "planRouteEmpty": "No tasks in this route",
     "planDriver": "Driver",
     "planVehicle": "Vehicle",
diff --git a/apps/web/src/locales/ru/translation.json b/apps/web/src/locales/ru/translation.json
index b5b5862..d6e888c 100644
--- a/apps/web/src/locales/ru/translation.json
+++ b/apps/web/src/locales/ru/translation.json
@@ -231,6 +231,9 @@
     "planRouteDistance": "Расстояние: {{distance}}",
     "planRouteDuration": "Время: {{duration}}",
     "planRouteEmpty": "Нет задач в этом маршруте",
+    "noGeoPointTitle": "Задачи без геоточки",
+    "noGeoPointHint": "Адрес сохранён, задача ожидает геокодирования.",
+    "noGeoPointLabel": "без геоточки",
     "planDriver": "Водитель",
     "planVehicle": "Транспорт",
     "planRouteNotes": "Заметки по маршруту",
diff --git a/apps/web/src/pages/Logistics.tsx b/apps/web/src/pages/Logistics.tsx
index d16a490..9476c06 100644
--- a/apps/web/src/pages/Logistics.tsx
+++ b/apps/web/src/pages/Logistics.tsx
@@ -636,6 +636,24 @@ const toPosition = (coords?: Coords | null): [number, number] | null => {
   return [lng, lat];
 };
 
+const hasCoords = (coords?: Coords | null) => Boolean(toPosition(coords));
+
+const normalizeLocation = (value: unknown): string => {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value.trim();
+  return trimmed;
+};
+
+const resolveLocation = (primary: unknown, fallback: unknown): string => {
+  const primaryValue = normalizeLocation(primary);
+  if (primaryValue) {
+    return primaryValue;
+  }
+  return normalizeLocation(fallback);
+};
+
 type AnimatedRoute = {
   taskId: string;
   title: string;
@@ -1228,6 +1246,25 @@ export default function LogisticsPage() {
     return counts;
   }, [categoryFilteredTasks]);
 
+  const geocodingQueue = React.useMemo(() => {
+    return categoryFilteredTasks.filter((task) => {
+      const details = (task as Record<string, unknown>).logistics_details as
+        | LogisticsDetails
+        | undefined;
+      const startLocation = resolveLocation(
+        details?.start_location,
+        (task as Record<string, unknown>).start_location,
+      );
+      const endLocation = resolveLocation(
+        details?.end_location,
+        (task as Record<string, unknown>).end_location,
+      );
+      const startMissing = Boolean(startLocation) && !hasCoords(task.startCoordinates);
+      const finishMissing = Boolean(endLocation) && !hasCoords(task.finishCoordinates);
+      return startMissing || finishMissing;
+    });
+  }, [categoryFilteredTasks]);
+
   const routeStatusMetadata = React.useMemo(() => {
     const entries = new Map<
       RouteStatusFilterKey,
@@ -2078,12 +2115,6 @@ export default function LogisticsPage() {
   );
 
   const filterRouteTasks = React.useCallback((input: RouteTask[]) => {
-    const hasPoint = (coords?: Coords | null) =>
-      typeof coords?.lat === 'number' &&
-      Number.isFinite(coords.lat) &&
-      typeof coords?.lng === 'number' &&
-      Number.isFinite(coords.lng);
-
     const result: RouteTask[] = [];
     input.forEach((task) => {
       const taskStatus =
@@ -2100,22 +2131,6 @@ export default function LogisticsPage() {
         | LogisticsDetails
         | undefined;
 
-      const resolveLocation = (primary: unknown, fallback: unknown): string => {
-        if (typeof primary === 'string') {
-          const value = primary.trim();
-          if (value) {
-            return value;
-          }
-        }
-        if (typeof fallback === 'string') {
-          const value = fallback.trim();
-          if (value) {
-            return value;
-          }
-        }
-        return '';
-      };
-
       const startLocation = resolveLocation(
         details?.start_location,
         (task as Record<string, unknown>).start_location,
@@ -2126,7 +2141,7 @@ export default function LogisticsPage() {
       );
 
       const hasCoordinates =
-        hasPoint(task.startCoordinates) || hasPoint(task.finishCoordinates);
+        hasCoords(task.startCoordinates) || hasCoords(task.finishCoordinates);
       const hasAddresses = Boolean(startLocation) || Boolean(endLocation);
 
       if (!hasCoordinates && !hasAddresses) {
@@ -3575,6 +3590,53 @@ export default function LogisticsPage() {
           {addressLayerNotice.text}
         </div>
       ) : null}
+      {geocodingQueue.length ? (
+        <div className="rounded-lg border border-slate-200 bg-slate-50 p-3 text-sm text-slate-700">
+          <div className="flex flex-wrap items-center justify-between gap-2">
+            <span className="font-semibold">
+              {t('logistics.noGeoPointTitle', {
+                defaultValue: 'Задачи без геоточки',
+              })}
+            </span>
+            <span className="text-xs text-muted-foreground">
+              {t('logistics.noGeoPointHint', {
+                defaultValue:
+                  'Адрес сохранён, задача ожидает геокодирования.',
+              })}
+            </span>
+          </div>
+          <div className="mt-2 flex flex-wrap gap-2">
+            {geocodingQueue.slice(0, 6).map((task) => {
+              const label =
+                typeof task.title === 'string' && task.title.trim()
+                  ? task.title.trim()
+                  : task._id;
+              return (
+                <span
+                  key={task._id}
+                  className="inline-flex items-center gap-2 rounded-full bg-slate-100 px-3 py-1 text-xs font-medium text-slate-800"
+                >
+                  <span
+                    className="inline-flex h-2.5 w-2.5 rounded-full bg-amber-500"
+                    aria-hidden
+                  />
+                  <span className="whitespace-nowrap">{label}</span>
+                  <span className="text-[11px] uppercase tracking-wide text-amber-700">
+                    {t('logistics.noGeoPointLabel', {
+                      defaultValue: 'без геоточки',
+                    })}
+                  </span>
+                </span>
+              );
+            })}
+            {geocodingQueue.length > 6 ? (
+              <span className="text-xs text-muted-foreground">
+                +{geocodingQueue.length - 6}
+              </span>
+            ) : null}
+          </div>
+        </div>
+      ) : null}
       <div className="grid gap-4 xl:grid-cols-[minmax(0,2fr)_minmax(0,1fr)]">
         <div className="space-y-4">
           <CollapsibleCard
diff --git a/scripts/backfill_task_coordinates.ts b/scripts/backfill_task_coordinates.ts
new file mode 100644
index 0000000..edb714c
--- /dev/null
+++ b/scripts/backfill_task_coordinates.ts
@@ -0,0 +1,108 @@
+// Назначение: заполнение координат логистических задач по адресам
+// Основные модули: Task модель, геокодер
+import mongoose from 'mongoose';
+import { Task, type TaskDocument } from '../apps/api/src/db/model';
+import { geocodeAddress } from '../apps/api/src/geo/geocoder';
+
+const hasCoords = (value?: { lat?: number | null; lng?: number | null } | null) =>
+  typeof value?.lat === 'number' &&
+  Number.isFinite(value.lat) &&
+  typeof value?.lng === 'number' &&
+  Number.isFinite(value.lng);
+
+const normalize = (value?: string | null): string => {
+  if (typeof value !== 'string') {
+    return '';
+  }
+  const trimmed = value.trim();
+  return trimmed;
+};
+
+const collectTasks = () =>
+  Task.find(
+    {
+      logistics_enabled: true,
+      $and: [
+        {
+          $or: [
+            { start_location: { $exists: true, $ne: '' } },
+            { end_location: { $exists: true, $ne: '' } },
+          ],
+        },
+        {
+          $or: [
+            { startCoordinates: { $exists: false } },
+            { finishCoordinates: { $exists: false } },
+            { startCoordinates: null },
+            { finishCoordinates: null },
+          ],
+        },
+      ],
+    },
+    {
+      start_location: 1,
+      end_location: 1,
+      startCoordinates: 1,
+      finishCoordinates: 1,
+      title: 1,
+    },
+  ).lean();
+
+const geocodeTask = async (task: TaskDocument) => {
+  const startLocation = normalize(task.start_location);
+  const endLocation = normalize(task.end_location);
+  const shouldGeocodeStart = startLocation && !hasCoords(task.startCoordinates);
+  const shouldGeocodeFinish = endLocation && !hasCoords(task.finishCoordinates);
+  if (!shouldGeocodeStart && !shouldGeocodeFinish) {
+    return null;
+  }
+
+  const updates: Partial<TaskDocument> = {};
+  if (shouldGeocodeStart) {
+    const coords = await geocodeAddress(startLocation);
+    if (coords) {
+      updates.startCoordinates = coords;
+    }
+  }
+  if (shouldGeocodeFinish) {
+    const coords = await geocodeAddress(endLocation);
+    if (coords) {
+      updates.finishCoordinates = coords;
+    }
+  }
+  return Object.keys(updates).length ? updates : null;
+};
+
+const applyUpdates = async (taskId: string, updates: Partial<TaskDocument>) => {
+  await Task.updateOne({ _id: taskId }, { $set: updates }).exec();
+};
+
+async function main() {
+  const tasks = await collectTasks();
+  if (!tasks.length) {
+    console.log('Логистических задач без координат не найдено');
+    await mongoose.disconnect();
+    return;
+  }
+
+  console.log(`Найдено задач для геокодирования: ${tasks.length}`);
+  let success = 0;
+  for (const task of tasks) {
+    const updates = await geocodeTask(task as TaskDocument);
+    if (!updates) {
+      continue;
+    }
+    await applyUpdates(String(task._id), updates);
+    success += 1;
+    const label = normalize(task.title) || String(task._id);
+    console.log(`Геокодирована задача: ${label}`);
+  }
+  console.log(`Обновлено задач: ${success}`);
+  await mongoose.disconnect();
+}
+
+main().catch(async (error) => {
+  console.error('Ошибка при заполнении координат:', error);
+  await mongoose.disconnect();
+  process.exit(1);
+});
