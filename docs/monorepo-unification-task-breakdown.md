# План унификации монорепозитория и shared-пакетов

## Цель

Перед настройкой отдельных сервисов проверить, что общие зависимости, правила сборки и shared-код максимально унифицированы и автоматизированы.

## Вариант A (минимальный, low-risk) — рекомендуемый старт

### Задача 1. Аудит текущей структуры workspace

**Что сделать**

- Подтвердить состав workspace (`apps/*`, `packages/*`, `scripts`) и роли пакетов.
- Зафиксировать, какие пакеты уже используют `shared`.

**Критерий готовности**

- Есть короткая матрица: пакет → тип (app/shared/tooling) → зависимость от `shared`.

### Задача 2. Унификация скриптов CI в package.json пакетов

**Что сделать**

- Добавить/выровнять минимальный набор скриптов: `build`, `lint`, `typecheck`, `test` (где применимо).
- Убрать расхождения в именовании (например единый `check`/`ci:fast` слой сверху).

**Критерий готовности**

- Все пакеты проходят единый pipeline из корня без ручных исключений.

### Задача 3. Централизация общих devDependency-правил

**Что сделать**

- Проверить, что версии TS/ESLint/Prettier/тестовых инструментов консистентны.
- Подтянуть дублирующиеся версии через root и `pnpm.overrides`, где это безопасно.

**Критерий готовности**

- Нет конфликтующих ключевых версий toolchain между пакетами.

### Задача 4. Укрепление shared как единой точки общего кода

**Что сделать**

- Явно описать публичные API `packages/shared` (экспорты, границы ответственности).
- Перенести только очевидные дубли из `apps/*` в `packages/shared` (без крупной архитектурной миграции).

**Критерий готовности**

- Повторяющийся код сокращен, импорты идут через `shared`, сборка стабильна.

### Задача 5. Проверка качества и фиксация baseline

**Что сделать**

- Прогнать обязательный набор проверок (install/build/tsc/test/lint).
- Зафиксировать baseline по времени и стабильности.

**Критерий готовности**

- Все обязательные проверки проходят, есть отчет «до/после».

## Вариант B (структурный, high-impact)

### Задача 1. Консолидация всех внутренних пакетов в `packages/*`

**Что сделать**

- Оставить в `apps/*` только запускаемые сервисы (`api`, `web`, `worker`).
- Весь переиспользуемый код вынести в отдельные пакеты внутри `packages/*` (`shared`, `config`, `types`, `utils`, и т.д.).

**Риск**

- Массовые изменения импортов и tsconfig paths.

### Задача 2. Введение package boundaries и контрактов

**Что сделать**

- Формализовать API каждого внутреннего пакета (exports map, semver-политика, правила зависимостей).
- Запретить «сквозные» импорты между приложениями.

**Риск**

- Потребуются точечные рефакторинги в каждом приложении.

### Задача 3. Оркестрация сборки/тестов через единый task runner

**Что сделать**

- Подключить Turborepo/Nx (или эквивалент) для кэша, графа задач и инкрементальных проверок.
- Стандартизировать `ci:fast`/`ci:full` на уровне монорепо.

**Риск**

- Миграционные накладные расходы и необходимость обучения команды.

## Рекомендованный порядок внедрения

1. Выполнить полностью Вариант A.
2. После стабилизации оценить ROI Варианта B.
3. Переходить к B только при явной выгоде (скорость CI/масштаб команды/рост shared-кода).

## Почему не «все пакеты в одну папку» прямо сейчас

- В репозитории уже есть рабочее разделение `apps/*` и `packages/*`.
- Полный перенос «за один шаг» повышает риск регрессий и усложняет настройку сервисов.
- Практичнее сначала унифицировать процессы и контракты, а затем делать структурную миграцию при необходимости.
